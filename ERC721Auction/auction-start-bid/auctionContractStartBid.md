在这个部分，我们将创建一个函数来开始拍卖，并创建一个函数来对NFT进行竞标。

### 开始
我们使用一些控制结构来检查是否满足条件，然后才允许卖家开始拍卖。

首先，我们检查拍卖是否已经开始（第49行）。如果已经开始并且状态变量`started`返回true，则退出函数并抛出异常。

第二个条件是检查执行该启动功能的帐户是否为卖方（第50行）。当他们部署合约时，我们已经创建了一个用于存储销售者地址的功能，并且现在可以检查执行`start`函数的帐户是否为销售者。如果不是，则抛出异常。

接下来，我们想将正在拍卖的NFT从销售者转移到合约中（第52行）。 我们将状态变量`started`设置为`true`（第53行），并创建了一个结束日期以结束拍卖（第54行）。在这种情况下，它将是从调用start函数开始的七天。我们可以使用像`days`这样的后缀来指定时间单位。如果您想了解更多关于时间单位的信息，请查看<a href="https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units" target="_blank">solidity 文档</a>。

最后，我们会发出`Start`事件（第56行）。

### 竞标
在函数调用者进行出价之前，我们需要确保满足某些条件。拍卖必须已经开始（第60行），拍卖不能已经结束（第61行），并且出价（与调用相关联的值）必须高于当前最高出价（第62行）。

现在，我们想要在进行新的竞标之前存储当前最高竞标人的出价。首先，我们检查是否有投标人（第64行）。如果这个函数调用是第一次投标，则下一行将无关紧要。在我们的mapping `bids` (第34行)中，使用竞价人的`地址`作为map的键，使用竞价人在撤回前的出价的ETH金额作为map的值。如果存在投标人，则将最高竞买者(`highestBidder`)的上次出价(`highestBid`)添加到他们所做出所有报价(`bids`) 的总值中(第65 行)，然后再撤回。 我们存储了这些报价，因为我们希望当竞价人不再是最高竞买者时可以提取他们的出价金额。

接下来，我们将`highestBidder`设置为调用该函数的账户( 第68 行)，并将`highestBid`设置为其所提交的`bid`，金额为该合约调用所发送的金额(第69行)。

最后，我们发出`Bid`事件(第71行)。

## ⭐️ 作业

1. 部署一个NFT合约。您可以使用我们在“Solidity NFT Course” Learneth课程中创建的NFT合约。
2. 铸造自己tokenId为0的NFT。
3. 部署这个EnglishAuction合约。将NFT合约地址作为`_nft`的参数，`_nftId`设置为0，`_startingBid`设置为1。
4. 调用您的NFT合约的`approve`函数，并将拍卖合同地址作为to的参数，`tokenId`设置为0。这将允许该合约转移要拍卖的代币。
5. 调用您拍卖合约的`start`函数。如果现在调用`started`函数，则应返回true。如果调用`highestBid`函数，则应返回1。
6. 将可以附加到交易中的值设置为3 Wei，并调用拍卖合同的`bid`函数。如果现在调用`highestBid`函数，则应返回3。
